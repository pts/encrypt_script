#!/bin/sh
#
# encrypt_script: Encrypt a Unix script with an interactive passphrase.
# by pts@fazekas.hu at Tue Nov 12 00:20:40 CET 2013
#
# The plaintext script must be a shell, Perl, Python or Ruby script. For
# non-shell scripts the appropriate shebang (#!) must be present.
#
# The encrypted script needs perl, stty and /bin/sh to run. Upon startup, it
# asks for a passphrase on stderr. In addition to that, ruby is needed for
# Ruby scripts and python is needed for Python 2.x scripts.
#
# The plaintext script can contain any binary byte except for NUL (\0). There
# no byte transliteration, non-ASCII bytes are preserved.
#
# Upon execution, the plaintext is never stored in a file, in a command-line
# argument or in an environment variable. The passphrase is stored in an
# environment variable, but not in a file or a command-line argument.
#
# TODO(pts): Add a salt.
# TODO(pts): Don't require Perl for Python or Ruby scripts at runtime.
# TODO(pts): Add Python 3 support.
# TODO(pts): In Python, allow module-level docstring and `from __future__'.
# TODO(pts): Do error messages have `-' as filename? Can we fix it?
#
PERL_BADLANG=x exec perl -x -- "$0" "$@"
#!perl -w
# TODO(pts): Fix line numbers because of `perl -x'.
use integer;
use strict;
#** @param $_[0] Binary string.
#** @return 32-bit integer.
sub adler32($) {
  my $a = 1;
  my $b = 0;
  my $i;
  my $c;
  for ($i = 0; $i < length $_[0]; ++$i) {
    $c = vec($_[0], $i, 8);
    $a = ($a + $c) % 65521;
    $b = ($b + $a) % 65521;
  }
  return ($b << 16) + $a;
}
#** @param $_[0]
sub rc4($$) {
  my(@t,@s);
  my$r="$_[1]";
  my@k=unpack('C*',$_[0]);
  my$x=0;my$y=0;
  for(@t=@s=0..255){$y=($k[$_%@k]+$s[$x=$_]+$y)&255;@s[$x,$y]=@s[$y,$x]}
  for(my$i=0;$i<length$_[1];++$i){
      $x++;$y=($s[$x&=255]+$y)&255;@s[$x,$y]=@s[$y,$x];
      vec($r,$i,8)^=$s[($s[$x]+$s[$y])&255]}
  $r
}

# As a side effect, puts STDERR to non-blocking mode.
sub prompt_passphrase($) {
  my $prompt = $_[0];
  die "error: Standard error is not a terminal.\n" if !-t STDERR;
  my $fd;
  # We have to open STDERR again, because Perl thinks it's for output only.
  die "error: Cannot open stderr for reading.\n" if !open $fd, '<&', 2;
  die "error: `ssty -echo' failed.\n" if 0 != system('stty -echo <&2');
  my $old = select(STDERR);
  print STDERR $prompt;
  select($old);
  $| = 1;
  my $pp = <$fd>;
  close($fd);
  die "error: `ssty echo' failed.\n" if 0 != system('stty echo <&2');
  print STDERR "\n";
  die "error: Could not read passphrase.\n" if !defined($pp) or !length($pp);
  chomp($pp);
  $pp
}

sub random($) {
  my $len = $_[0];
  my $s = "\0" x $len;
  for (my $i = 0; $i < $len; ++$i) {
    vec($s, $i, 8) = int(rand(256));
  }
  $s;
}

#** Derives an encryption key from a passphrase.
#** TODO(pts): Make this slower to make brute force attacks slower.
#** TODO(pts): Add better http://en.wikipedia.org/wiki/Key_derivation_function
sub derive_key($) {
  my $pp = $_[0];
  my $key = '';
  my $i = 13;
  while (length($key) < 1024) {
    my $ipp = "$i$pp";
    $key .= $ipp . pack('N', adler32($ipp));
    ++$i;
  }
  $key .= pack('N', adler32($key));
  $key
}

my $pp = prompt_passphrase("Enter encryption passphrase: ");
die "error: Passphrase is empty.\n" if !length($pp);
my $pp2 = prompt_passphrase("Repeat encryption passphrase: ");
die "error: Passphrases do not match.\n" if $pp ne $pp2;
my $key = derive_key($pp);
print STDERR "info: Reading plaintext shell script from stdin.\n";
my $msg = join('', <STDIN>);
# This can break `eval' in some shells. Python also doesn't allow \0.
# Just play it safe, and preemptively disallow it for Perl and Ruby as well.
die "error: NUL not allowed in plaintext\n" if $msg =~ /\0/;
# TODO(pts): Support bash*, perl*, ruby*, python* etc., also with /usr/bin/env.
# Don't forget about the `exec <&8 8<&-;' magic added below.
my $type;
my $arg_w = '';
if (substr($msg, 0, 2) eq '#!') {
  pos($msg) = 0;
  my $is_at_top;
  my $cmd;
  if (($msg =~ m@^#!(.*perl.*)\n@mg or
       $msg =~ m@^#!(.*ruby.*)\n@mg or
       $msg =~ m@^#!(.*python.*)\n@mg) and
      ($cmd = $1) and
      substr($msg, 0, pos($msg)) =~ y@\n@@ < 16 and
      (($is_at_top = pos($msg) - length($1) == 3) or  # length("#!\n") == 3.
       $msg =~ m@\A#! */bin/(?:ba|da)sh(?: *--)?\n@)) {
    die if $cmd !~ s@\s*(\S+)\s*@@;  # Remove the program, keep the argument.
    my $prog = $1;
    my $is_perl = index($prog, 'perl') >= 0;
    my $is_ruby = index($prog, 'ruby') >= 0;
    my $is_python = index($prog, 'python') >= 0;
    die "error: Ambiguous script type in shebang: $prog $cmd\n" if
        $is_perl + $is_ruby + $is_python > 1;
    $type = $is_perl ? 'perl' : $is_python ? 'python' : $is_ruby ? 'ruby' :
        undef;
    die 'assert' if !defined($type);
    my $typeu = ucfirst($type);
    die "error: Python shebang must be at the top\n" if
        $type eq 'python' and not $is_at_top;
    $cmd =~ s@\s+\Z(?!\n)@@;
    if ($cmd eq '-w' and $type ne 'python') { $arg_w = ' -w' }
    elsif ($cmd eq '') { $arg_w = '' }
    else { die "error: Unsupported $typeu shebang flag: $cmd\n" }
    # Remove the shebang line, but keep the newlines.
    substr($msg, 0, pos($msg)) = "\n" x (
        substr($msg, 0, pos($msg)) =~ y@\n@@ or 0);
  } elsif ($msg =~ m@\A(#! */bin/sh(?: *--)?\n(?:[ \t]*(?:#.*)?\n)*""":")@) {
    my $slen = length($1);
    # Python script with the magic header (e.g. joenc).
    pos($msg) = 0;
    die "error: Could not find end of magic Python header\n" if
        $msg !~ m@\nexec python -- .*;[ \t]*exit[ \t]+1[ \t]*\n@mg or
        substr($msg, $slen, pos($msg)) =~ y@\n@@ >= 16;
    $type = 'python';
  } elsif ($msg =~ s@\A#! */bin/sh(?: *--)?\n@@) {  # Shell script.
    $type = 'sh';
  } else {
    $msg =~ m@\A(.*)@;
    die "error: Unrecognized shebang (Perl and shell are allowed): $1\n";
  }
} else {
  $type = 'sh';
}
# Add a leading newline as a separator. This screws up line numbering, but
# we can't add `;' because it's not possible to have a compound statement in
# the same line. Usually we won't prepend anything, because there is a shebang
# or a following \n.
substr($msg, 0, 0) = "\n" if $type eq 'python' and
    $msg =~ m/\A(?:\@|(?:from|while|import|with|if|try|class|def|for)\b)/;
    # $msg !~ m@\A[ \t]*(?:#.*)$@m;

# This acts as a salt and also overcomes the weaknesses of the initial bytes
# of RC4.
substr($msg, 0, 0) = random(16);
my $ct = rc4($key, $msg . pack('N', adler32($msg)));
my $e = pack('u', $ct . pack('N', adler32($ct)));

# Verify that it's possible to decrypt it.
{
  my $d = unpack('u', $e);
  die "decrypt error: Too short.\n" if length($d) < 8;
  my $a = unpack('N', substr($d, -4));
  substr($d, -4) = '';
  die "decrypt error: Transmission failure.\n" if $a != adler32($d);
  $d = rc4($key, $d);
  $a = unpack('N', substr($d, -4));
  substr($d, -4) = '';
  die "decrypt error: Bad passphrase.\n" if $a != adler32($d);
  die "decrypt error: Plaintext mismatch.\n" if $d ne $msg;
}

print STDERR "info: Wrinting encrypted script to standard output.\n";
# Works with bash 4.1.5, dash 0.5.5.1, busybox sh 1.13.3.
# Not using `read -p ... ps', bacause dash 0.5.5.1 doesn't have it.
#
# TODO(pts): What if stderr is also redirected? Try using /dev/tty?
# TODO(pts): Make $0 print the right thing in the shell script. Can it work?
# TODO(pts): stdin redirection (exec <&8) makes the shell stop reading stdin
#   in bash 3.2.39.
my $head_code = <<'END';
#!/bin/sh --
stty -echo<&2||exit 124;echo -n "Enter passphrase for runnin\
g $0: ">&2;IFS= read P<&2;echo>&2;stty echo<&2;test "$P"||
exit 124
END
my $execdec_code = q(P="$P" exec perl -x "$0" "$@";exit 1) . "\n";
my $strict_code = "#!perl -w\nuse integer;use strict;\n";
my $decrypt_code = <<'END';
sub A($){my$a=1;my$b=0;my$c;for(my$i=0;$i<length$_[0];++$i){
my$c=vec($_[0],$i,8);$a=($a+$c)%65521;$b=($b+$a)%65521}$b<<16
|$a}sub D($){my$pp=$_[0];my$key='';my$i=13;while(length$key<
1024){my$ipp="$i$pp";$key.=$ipp.pack('N',A($ipp));++$i}$key.=
pack('N',A($key));$key}my$d=unpack('u',join('',<DATA>));
die"decrypt error: Too short.\n"if!defined($d)||length($d)<24
;my$a=unpack('N',substr($d,-4));substr($d,-4)='';
die"decrypt error: Transmission failure.\n"if$a!=A($d);
{my(@t,@s);my@k=unpack('C*',D($ENV{P}));my$x=0;my$y=0;
for(@t=@s=0..255){$y=($k[$_%@k]+$s[$x=$_]+$y)&255;@s[$x,$y]=
@s[$y,$x]}for(my$i=0;$i<length$d;++$i){$x++;$y=($s[$x&=255]+
$y)&255;@s[$x,$y]=@s[$y,$x];vec($d,$i,8)^=$s[($s[$x]+$s[$y])&
255]}}$a=unpack('N',substr($d,-4));substr($d,-4)='';
die"decrypt error: Bad passphrase.\n"if$a!=A($d);
substr($d,0,16)='';print$d;__DATA__
END

# Don't use eval($d) above, it's not equivalent if the source contains
# non-printable bytes etc.
# TODO(pts): Don't add PID ($q) to the command line, it interferes with ps(1).
my $pipe_code = <<'END';
my($r,$w);die"error: pipe: $!"if!pipe($r,$w);my$q=fork;die
"error: fork: $!"if!defined$q;if($q){close($w);delete$ENV{P};
if(fileno($r)){die"error: redirect stdin: $!\n"if!open STDIN,
"<&",fileno$r;}die"error: exec INTERP: $!\n"if!exec"INTERP",
"-w","-",$q,$0,@ARGV}die"error: redirect stdout: $!\n"if!open
STDOUT,">&",fileno($w);close($r);$|=1;print
END
chomp($pipe_code);
my $perl_pipe_code = << 'END';
 q(BEGIN{my$q=).
q(shift;die"error: waitpid: $!"if $q!=(waitpid($q,0)||0);ex).
q(it(255)if$?;$0=shift});
END
my $python_pipe_code = << 'END';
 q%exec"import o%.
q%s,sys;a=sys.argv;p=int(a.pop(1))\nif(p,0)!=os.waitpid(p,0%.
q%):sys.exit(255)\ndel a[0]"in{};%;
END
my $ruby_pipe_code = << 'END';
 q%[ARGV.delete_%.
q%at(0).to_i].each{|q|exit(255)if q!=Process.waitpid(q);ARG%.
q%V.delete_at 0};%;
END

if ($type eq 'sh') {
  print $head_code, 'eval "unset P;$(P="$P" perl -x -- "$0")";exit', "\n",
        $strict_code, $decrypt_code, $e;
} elsif ($type eq 'perl') {
  my $pc = $pipe_code;
  $pc =~ s@\n"-w",@\n@ if !$arg_w;
  die if $pc !~ s@INTERP@$type@g;
  print $head_code, $execdec_code,
        $strict_code, $pc, $perl_pipe_code, $decrypt_code, $e;
} elsif ($type eq 'python') {
  my $pc = $pipe_code;
  die if $pc !~ s@INTERP@$type@g;
  die "-w not allowed for Python." if $arg_w;
  $pc =~ s@\n"-w",@\n@ if !$arg_w;
  print $head_code, $execdec_code,
        $strict_code, $pc, $python_pipe_code, $decrypt_code, $e;
} elsif ($type eq 'ruby') {
  my $pc = $pipe_code;
  die if $pc !~ s@INTERP@$type@g;
  $pc =~ s@\n"-w",@\n@ if !$arg_w;
  print $head_code, $execdec_code,
        $strict_code, $pc, $ruby_pipe_code, $decrypt_code, $e;
}
