#!/bin/sh
#
# encrypt_script: Encrypt a Unix script with an interactive passphrase.
# by pts@fazekas.hu at Tue Nov 12 00:20:40 CET 2013
#
# The encrypted script needs Perl, stty and /bin/sh to run. Upon startup, it
# asks for a passphrase on stderr.
PERL_BADLANG=x exec perl -x -- "$0" "$@"
#!perl -w
# TODO(pts): Fix line numbers because of `perl -x'.
use integer;
use strict;
#** @param $_[0] Binary string.
#** @return 32-bit integer.
sub adler32($) {
  my $a = 1;
  my $b = 0;
  my $i;
  my $c;
  for ($i = 0; $i < length $_[0]; ++$i) {
    $c = vec($_[0], $i, 8);
    $a = ($a + $c) % 65521;
    $b = ($b + $a) % 65521;
  }
  return ($b << 16) + $a;
}
#** @param $_[0]
sub rc4($$) {
  my(@t,@s);
  my$r="$_[1]";
  my@k=unpack('C*',$_[0]);
  my$x=0;my$y=0;
  for(@t=@s=0..255){$y=($k[$_%@k]+$s[$x=$_]+$y)&255;@s[$x,$y]=@s[$y,$x]}
  for(my$i=0;$i<length$_[1];++$i){
      $x++;$y=($s[$x&=255]+$y)&255;@s[$x,$y]=@s[$y,$x];
      vec($r,$i,8)^=$s[($s[$x]+$s[$y])&255]}
  $r
}

# As a side effect, puts STDERR to non-blocking mode.
sub prompt_passphrase($) {
  my $prompt = $_[0];
  die "error: Standard error is not a terminal.\n" if !-t STDERR;
  my $fd;
  # We have to open STDERR again, because Perl thinks it's for output only.
  die "error: Cannot open stderr for reading.\n" if !open $fd, '<&', 2;
  die "error: `ssty -echo' failed.\n" if 0 != system('stty -echo <&2');
  my $old = select(STDERR);
  print STDERR $prompt;
  select($old);
  $| = 1;
  my $pp = <$fd>;
  close($fd);
  die "error: `ssty echo' failed.\n" if 0 != system('stty echo <&2');
  print STDERR "\n";
  die "error: Could not read passphrase.\n" if !defined($pp) or !length($pp);
  chomp($pp);
  $pp
}

sub random($) {
  my $len = $_[0];
  my $s = "\0" x $len;
  for (my $i = 0; $i < $len; ++$i) {
    vec($s, $i, 8) = int(rand(256));
  }
  $s;
}

#** Derives an encryption key from a passphrase.
#** TODO(pts): Make this slower to make brute force attacks slower.
#** TODO(pts): Add better http://en.wikipedia.org/wiki/Key_derivation_function
sub derive_key($) {
  my $pp = $_[0];
  my $key = '';
  my $i = 13;
  while (length($key) < 1024) {
    my $ipp = "$i$pp";
    $key .= $ipp . pack('N', adler32($ipp));
    ++$i;
  }
  $key .= pack('N', adler32($key));
  $key
}

my $pp = prompt_passphrase("Enter encryption passphrase: ");
die "error: Passphrase is empty.\n" if !length($pp);
my $pp2 = prompt_passphrase("Repeat encryption passphrase: ");
die "error: Passphrases do not match.\n" if $pp ne $pp2;
my $key = derive_key($pp);
print STDERR "info: Reading plaintext shell script from stdin.\n";
my $msg = join('', <STDIN>);
# This can break `eval' in some shells.  # !! not for Perl
die "error: NUL not allowed in plaintext\n" if $msg =~ /\0/;
# TODO(pts): Support bash*, perl*, ruby*, python* etc., also with /usr/bin/env.
# Don't forget about the `exec <&8 8<&-;' magic added below.
my($type, $perl_w);
if (substr($msg, 0, 2) eq '#!') {
  pos($msg) = 0;
  if ($msg =~ m@^#!(.*perl.*)\n@mg and
      substr($msg, 0, pos($msg)) =~ y@\n@@ < 16 and
      (pos($msg) - length($1) == 3 or
       1)) {  #$msg =~ m@\A#! */bin/(?:ba|da)sh(?: *--)?\n@)) {
    my $cmd = $1;
    die if $cmd !~ s@\s*\S+\s*@@;  # Remove the program, keep the argument.
    $cmd =~ s@\s+\Z(?!\n)@@;
    $type = 'perl';
    if ($cmd eq '-w') { $perl_w = ' -w' }
    elsif ($cmd eq '') { $perl_w = '' }
    else { die "error: Unsupported Perl shebang flag: $cmd\n" }
    substr($msg, 0, pos($msg)) = '';  # Remove the shebang line.
  } elsif ($msg =~ s@\A#! */bin/sh(?: *--)?\n@@) {  # Shell script.
    $type = 'sh';
  } else {
    $msg =~ m@\A(.*)@;
    die "error: Unrecognized shebang (Perl and shell are allowed): $1\n";
  }
} else {
  $type = 'sh';
}
# This acts as a salt and also overcomes the weaknesses of the initial bytes
# of RC4.
substr($msg, 0, 0) = random(16);
my $ct = rc4($key, $msg . pack('N', adler32($msg)));
my $e = pack('u', $ct . pack('N', adler32($ct)));

# Verify that it's possible to decrypt it.
{
  my $d = unpack('u', $e);
  die "decrypt error: Too short.\n" if length($d) < 8;
  my $a = unpack('N', substr($d, -4));
  substr($d, -4) = '';
  die "decrypt error: Transmission failure.\n" if $a != adler32($d);
  $d = rc4($key, $d);
  $a = unpack('N', substr($d, -4));
  substr($d, -4) = '';
  die "decrypt error: Bad passphrase.\n" if $a != adler32($d);
  die "decrypt error: Plaintext mismatch.\n" if $d ne $msg;
}

print STDERR "info: Wrinting encrypted script to standard output.\n";
# Works with bash 4.1.5, dash 0.5.5.1, busybox sh 1.13.3.
# Not using `read -p ... ps', bacause dash 0.5.5.1 doesn't have it.
#
# TODO(pts): What if stderr is also redirected? Try using /dev/tty?
# TODO(pts): Make $0 print the right thing in the shell script. Can it work?
# TODO(pts): stdin redirection (exec <&8) makes the shell stop reading stdin
#   in bash 3.2.39.
#<GF8P_2!7J&T="U&]_UT^$JN07.'*;5Y1"7$@*5]"C6L?X5U/=*RSP?A82'P
my $head_code = <<'END';
#!/bin/sh --
stty -echo<&2||exit 124;echo -n "Enter passphrase for runnin\
g $0: ">&2;IFS= read P<&2;echo>&2;stty echo<&2;test "$P"||
exit 124
END
my $strict_code="#!perl -w\nuse integer;use strict;\n";
my $decrypt_code = <<'END';
sub A($){my$a=1;my$b=0;my$c;for(my$i=0;$i<length$_[0];++$i){
my$c=vec($_[0],$i,8);$a=($a+$c)%65521;$b=($b+$a)%65521}$b<<16
|$a}sub D($){my$pp=$_[0];my$key='';my$i=13;while(length$key<
1024){my$ipp="$i$pp";$key.=$ipp.pack('N',A($ipp));++$i}$key.=
pack('N',A($key));$key}my$d=unpack('u',join('',<DATA>));
die"decrypt error: Too short.\n"if!defined($d)||length($d)<24
;my$a=unpack('N',substr($d,-4));substr($d,-4)='';
die"decrypt error: Transmission failure.\n"if$a!=A($d);
{my(@t,@s);my@k=unpack('C*',D($ENV{P}));my$x=0;my$y=0;
for(@t=@s=0..255){$y=($k[$_%@k]+$s[$x=$_]+$y)&255;@s[$x,$y]=
@s[$y,$x]}for(my$i=0;$i<length$d;++$i){$x++;$y=($s[$x&=255]+
$y)&255;@s[$x,$y]=@s[$y,$x];vec($d,$i,8)^=$s[($s[$x]+$s[$y])&
255]}}$a=unpack('N',substr($d,-4));substr($d,-4)='';
die"decrypt error: Bad passphrase.\n"if$a!=A($d);
substr($d,0,16)='';print$d;__DATA__
END

# Don't use eval($d) above, it's not equivalent if the source contains
# non-printable bytes etc.
my $perl_pipe_code = <<'END';
my($r,$w);die"error: pipe: $!"if!pipe($r,$w);my$q=fork;die
"error: fork: $!"if!defined$q;if($q){close($w);delete$ENV{P};
if(fileno($r)){die"error: redirect stdin: $!\n"if!open STDIN,
"<&", fileno($r);}die"error: exec perl: $!\n"if!exec"perl",
"-w","-",$q,$0,@ARGV}die"error: redirect stdout: $!\n"if!open
STDOUT,">&",fileno($w);close($r);$|=1;print q(BEGIN{my$q=).
q(shift;die"error: waitpid: $!"if $q!=(waitpid($q,0)||0);ex).
q(it(255)if$?;$0=shift});
END
if ($type eq 'sh') {
  print $head_code, 'eval "unset P;$(P="$P" perl -x -- "$0")";exit', "\n",
        $strict_code, $decrypt_code, $e;
} elsif ($type eq 'perl') {
  my $pc = $perl_pipe_code;
  $pc =~ s@\n"-w",@@ if !$perl_w;
  print $head_code, 'P="$P" exec perl -x "$0" "$@"', "\n",
        $strict_code, $pc, $decrypt_code, $e;
}
